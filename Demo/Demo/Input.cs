using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework;

namespace GemGuiTest
{
    /// <summary>
    /// Translates windows keyboard messages into a form consumable by the GUI.
    /// </summary>
    public class KeyboardInput
    {
        public enum WindowMessage
        {
            WM_KEYDOWN = 0x100,
            WM_KEYUP = 0x101,
            WM_CHAR = 0x102,
        };

        // Need a thread-safe queue of events, since these are generated by the windows message pump.

        public class QueuedInput
        {
            public GemGui.KeyEvents Message;
            public GemGui.KeyEventArgs Args;
        }

        public System.Threading.Mutex QueueLock = new System.Threading.Mutex();
        public List<QueuedInput> Queued = new List<QueuedInput>();

        public List<QueuedInput> GetInputQueue()
        {
            QueueLock.WaitOne();
            var r = Queued;
            Queued = new List<QueuedInput>();
            QueueLock.ReleaseMutex();
            return r;
        }

        public KeyboardInput(IntPtr WindowHandle)
        {
            KeyboardMessageFilter.AddKeyboardMessageFilter((c) => HandleKeyPress(c));
        }

        private void HandleKeyPress(System.Windows.Forms.Message Msg)
        {
            QueueLock.WaitOne();

            switch ((WindowMessage)Msg.Msg)
            {
                case WindowMessage.WM_CHAR:
                    {
                        var args = new System.Windows.Forms.KeyPressEventArgs((char)Msg.WParam);
                        Queued.Add(new QueuedInput
                        {
                            Message = GemGui.KeyEvents.KeyPress,
                            Args = new GemGui.KeyEventArgs
                            {
                                KeyData = args.KeyChar,
                                KeyValue = args.KeyChar,
                                Alt = false,
                                Control = false,
                                Shift = false
                            }
                        });
                        break;
                    }
                case WindowMessage.WM_KEYDOWN:
                    {
                        var args = new System.Windows.Forms.KeyEventArgs((System.Windows.Forms.Keys)Msg.WParam);
                        Queued.Add(new QueuedInput
                            {
                                Message = GemGui.KeyEvents.KeyDown,
                                Args = new GemGui.KeyEventArgs
                                {
                                    Alt = args.Alt,
                                    Control = args.Control,
                                    Shift = args.Shift,
                                    KeyData = (int)args.KeyData,
                                    KeyValue = args.KeyValue
                                }
                            });
                        break;
                    }
                case WindowMessage.WM_KEYUP:
                    {
                        var args = new System.Windows.Forms.KeyEventArgs((System.Windows.Forms.Keys)Msg.WParam);
                        Queued.Add(new QueuedInput
                            {
                                Message = GemGui.KeyEvents.KeyUp,
                                Args = new GemGui.KeyEventArgs
                                {
                                    Alt = args.Alt,
                                    Control = args.Control,
                                    Shift = args.Shift,
                                    KeyData = (int)args.KeyData,
                                    KeyValue = args.KeyValue
                                }
                            });
                        break;
                    }
            }

            QueueLock.ReleaseMutex();
        }

    }
}
